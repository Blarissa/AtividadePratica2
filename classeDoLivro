import java . util . Iterator ;
import java . util . NoSuchElementException ;

/ ** 
* A classe { @code LinkedQueue} representa uma 
fila 
primeiro a entrar, primeiro a sair (FIFO) * de itens genéricos. * Ele suporta o habitual <em> enqueue </ em> e <em> dequeue </ em> 
* operações, juntamente com métodos para espreitar o primeiro item, 
* testar se a fila está vazia, e iteração 
* os itens Pedido FIFO. 
*   <p> 
* Esta implementação usa uma lista vinculada individualmente com uma classe aninhada não estática 
* para nós de lista vinculada. Consulte { @link Queue} para uma versão que usa uma classe aninhada estática. 
* O <em> enfileirar </em>, <em> retirar da fila </em> , <em> peek </em> , <em> size </em> e <em> is-empty </em> 
* as operações levam um tempo constante no pior caso. 
*   <P> 
* Para documentação adicional, consulte <a href = "https://algs4.cs.princeton.edu/13stacks"> Seção 1.3 </a> de *   <i> Algoritmos, 4ª Edição </ i> por Robert Sedgewick e Kevin Wayne. 



Kevin Wayne 
* / 
public class LinkedQueue < Item > implementa Iterable < Item > { private int n ; // número de elementos na fila private Node first ; // início da fila private Node last ; // fim da fila    
              
         
          

    // ajudante ligada classe de lista 
privada class Node { privada item artigo ; próximo nó privado ; }       
         
         
    

    / ** 
     * Inicializa uma fila vazia. 
     * / 
public LinkedQueue () {         first = null ;         último   = nulo ;         n = 0 ; assert check (); }      
 
 
 
         
    

    / ** 
     * Esta fila está vazia? 
     * @return true se esta fila estiver vazia; caso contrário, falso 
     * / 
public boolean isEmpty () { return first == null ; }       
         
    

    / ** 
     * Retorna o número de itens nesta fila. 
     * @return o número de itens nesta fila 
     * / 
public int size () { return n ; }       
             
    

    / ** 
     * Retorna o item adicionado menos recentemente a esta fila. 
     * @return o item adicionado menos recentemente a esta fila 
     * @throws java.util.NoSuchElementException se esta fila estiver vazia 
     * / 
public Item peek () { if ( isEmpty ()) throw new NoSuchElementException ( "Queue underflow" ); volte primeiro . item ; }       
            
        
    

    / ** 
     * Adiciona o item a esta fila. 
     * @param item o item a ser adicionado 
     * / 
public void enqueue ( item de item ) { Node oldlast = last ;         último = novo nó ();         último . item = item ;         último . próximo = nulo ; if ( isEmpty ()) primeiro = último ; mais            antigo       
        
  

 
         
        . próximo = último ; 
        n ++; 
assert check (); }         
    

    / ** 
     * Remove e retorna o item nesta fila que foi adicionado menos recentemente. 
     * @return o item nesta fila que foi adicionado pelo menos recentemente 
     * @throws java.util.NoSuchElementException se esta fila estiver vazia 
     * / 
public Item dequeue () { if ( isEmpty ()) throw new NoSuchElementException ( "Queue underflow" ); Item item = primeiro . item ;         primeiro = primeiro . próximo ;       
            
        

        n -; 
if ( isEmpty ()) last = null ; // para evitar ociosidade assert check (); item de retorno ; }             
         
        
    

    / ** 
     * Retorna uma representação de string desta fila. 
     * @return a sequência de itens na ordem FIFO, separados por espaços 
     * / 
public String toString () { StringBuilder s = new StringBuilder (); para ( item do item : este )             s . anexar ( item + "" ); return s . toString (); }       
          
          
 
        
     

    // verifica invariantes internos 
private boolean check () { if ( n < 0 ) { return false ; } else if ( n == 0 ) { if ( first ! = null ) return false ; if ( last   ! = null ) retorna false ; } else if ( n == 1 ) { if       
           
             
        
            
                
                
        
            
             ( primeiro == nulo || último == nulo ) retorna falso ; if ( primeiro ! = último ) retorna falso ; if ( primeiro . próximo ! = null ) retorna falso ; } else { if ( first == null || last == null ) return false ; if ( primeiro == último     
                               
                           
        
         
                  
             ) return false ; if ( first . next == null ) return false ; if ( last . next   ! = null ) return false ;       
                
                

            // verificar a consistência interna da variável de instância n 
int numberOfNodes = 0 ; para ( Nó x = primeiro ; x ! = nulo && numberOfNodes <= n ; x = x . próximo ) {                 numberOfNodes ++; } if ( numberOfNodes ! = n ) retorna falso ;             
                

            
               

            // verifica a consistência interna da variável de instância último 
Nó lastNode = primeiro ; while ( lastNode . next ! = null ) {                 lastNode = lastNode . próximo ; } if ( last ! = lastNode ) return false ; }            
               

            
               
        

        return true ; } 
     
 

    / ** 
     * Retorna um iterador que itera sobre os itens nesta fila na ordem FIFO. 
     * @return um iterador que itera sobre os itens nesta fila na ordem FIFO 
     * / 
public Iterator <Item> iterator () { return new LinkedIterator (); }        
            
    

    // um iterador, não implementa remove () porque é 
uma classe privada opcional LinkedIterator implementa Iterator < Item > { private Node current = first ;        
         

        public boolean hasNext () { return current ! = null ; } public void remove () { lance novo UnsupportedOperationException (); }                           
                     

        public Item next () { if (! hasNext ()) throw new NoSuchElementException (); Item item = atual . item ;             atual = atual . próximo ; item de retorno ; } }   
                
            
 
            
        
    


    / ** 
     * A unidade testa o tipo de dados { @code LinkedQueue}. 
     * 
     * @param args os argumentos da linha de comando 
     * / 
public static void main ( String [] args ) { LinkedQueue <String> queue = new LinkedQueue < String > (); enquanto (! StdIn . isEmpty ()) { Cadeia artigo = StdIn . readString (); if (! item .        
         
          
            
             igual a ( "-" )) 
                fila . enfileirar ( item ); 
else if (! queue . isEmpty ())                 StdOut . imprimir ( fila . dequeue () + "" ); }         StdOut . println ( "(" + fila . size () + "deixado na fila)" ); } }              
  
        
   
